// * 21.0 В ES6 появились новые методы работы с числами: "Number.isNaN", "Number.isFinite" & "Math.trunc".
// ? 21.1.0 Более старый метод "isNaN", который в JS с самого его появления возвращал булево значение, в зависимости, если помещённое в него значение не является числом.
console.log(isNaN(5)); // false
console.log(isNaN('JS')); // true
console.log(isNaN(NaN)); // true

// ? 21.1.1 Однако метод "isNaN" глобального объекта Number возвращает булево значение, основываясь на том является ли помещённое в него значение типом "NaN". Давайте сравним его со старой версией "isNaN". Т.е. "Number.isNaN" вернёт "true" исключительно в случае, если значение в буквальном смысле NaN. Это даёт разработчику более точный инструмент определения, что значение NaN.
console.log(Number.isNaN(5)); // false
console.log(Number.isNaN('JS')); // false
console.log(Number.isNaN(NaN)); // true

// ======= //
// ? 21.2 При помощи "Number.isFinite" мы можем определить является ли число конечным или нет (это такое число, которое можно посчитать). Раньше использовался одноимённый "isFinite", но он давал некорректные данные из-за динамической конвертации строки в число.
console.log(isFinite(0)); // true
console.log(isFinite('0')); // true

// 21.2.1 Итак, чтобы избежать этой конвертации и иметь более точный инструмент был добавлен также метод глоб. объекта Number "isFinite". Как мы видим, этот метод не конвертировал строку в число и просто вернул false.
console.log(Number.isFinite(0)); // true
console.log(Number.isFinite('0')); // false

// ======= //
// ? 21.3.0 Также в ES6 появился новый метод глоб. объекта Math — 'trunc', который попросту обрезает у дробных чисел дроби.
console.log(Math.trunc(12.345)); // 12
console.log(Math.trunc(-45.679)); // -45
console.log(Math.trunc(15 / 90)); // 0
console.log(Math.trunc('-24.35')); // -24
console.log(Math.trunc({})); // NaN

// 21.3.1 Своим поведением напоминает метод "parseInt", куда мы можем поместить число с дробным остатком и он также обрежет его.
console.log(parseInt(12.345)); // 12
console.log(parseInt('80.88')); // 80

// ? 21.3.2 Однако, когда мы работаем с числами может быть более удобно работать с "Math.trunc", чем с "parseInt" (см. ссылки).
