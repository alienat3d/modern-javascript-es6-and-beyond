// * 16.0 Метод массивов "reduce".
// 16.1.0 Добавим нашему знакомому массиву с командой также информацию о заработанных, каждым игроком очков. Теперь попробуем сосчитать общее кол-во очков команды с помощью метода "reduce".
const team = [
  { name: 'Liam Chen', nationality: 'Chinese', points: 100 },
  { name: 'Olivia Rose Peterson', nationality: 'American', points: 93 },
  { name: 'Ethan James Williams', nationality: 'British', points: 64 },
  { name: 'Ava Nicole Rodriguez', nationality: 'Mexican', points: 58 },
  { name: 'Noah Carter', nationality: 'Jewish', points: 115 },
  { name: 'Isabella Miller', nationality: 'Spanish', points: 97 },
  { name: 'Jacob Davis', nationality: 'Jewish', points: 71 },
];

// 16.1.1 Но для начала, вспомним, как бы мы это делали с помощью цикла for in.
let points = 0;

for (const member in team) {
  points += team[member].points;
}

console.log(points);

// 16.1.2 И, хотя это был абсолютно адекватный способ сосчитать очки команды, но с помощью "reduce" мы можем сделать это проще и лаконичнее. Для начала создадим массив, где каждым элементом будут очки каждого члена команды.
const pointsArr = team.map((member) => member.points);

console.log(pointsArr);

// ? 16.1.3 Итак, метод "reduce" принимает два аргумента: 1) аккумулятор "acc" (переменная, которая содержит в себе общий результат от выполнения предыдущей коллбэк-функции), 2) текущее значение "cur". Затем каждую итерацию к аккумулятору будет прибавляться текущее значение current, или числа-элемента в массиве, который на очереди в переборе, чтобы в итоге результатом стало одно значение или сумма всех чисел перебираемого массива.
// ? 16.1.4 Мы можем также передать изначальное значение в метод "reduce", это будет тем значением, к которому будет прибавляться текущее значение "current" уже на первой итерации. Если его не указывать, что этим значением будет первое значение в перебираемом массиве, а текущим второе. Это может быть очень полезно, если мы работаем с массивами, которые могут оказаться пустыми.
const totalPoints = pointsArr.reduce(
  (accumulator, current) => accumulator + current,
  100
);

console.log(totalPoints);

// 16.2 На примере этой функции, если мы не укажем изначальное значение и попробуем подставить в функцию пустой массив, то получим ошибку, если же мы хотим вместо этого всегда получать 0, то надо указать изначальным числом 0.
function getSum(list) {
  return list.reduce((acc, cur) => acc + cur, 0);
}

console.log(getSum([2, 3, 4, 5]));
console.log(getSum([]));

// 16.3.0 Мы можем использовать метод "reduce" в очень разнообразных случаях, не только с числами. Рассмотрим также следующий массив с объектами. И мы хотим, например, создать ещё один массив, который бы объединил все компании, найденные в каждом из объектов этого массива.
const CEOs = [
  { name: 'Elon Musk', companies: ['Tesla', 'SpaceX', 'Starlink', 'X'] },
  { name: 'Mark Zuckerberg', companies: ['Facebook', 'WhatsApp', 'Instagram'] },
  {
    name: 'Jeff Bezos',
    companies: ['Amazon', 'Blue Origin', 'The Washington Post'],
  },
];

// 16.3.1 Мы также можем это сделать при помощи метода "reduce" "склеив" все этим массивы. Изначальным значением у нас тут будет пустой массив с которым мы совмещаем, применением метода "concat" первый массив с названиями компаний Маска, затем в аккумуляторе остаётся этот результат с массивом, а в "cur" попадает уже следующий массив с компаниями Цукерберга, которые также присоединяются к первому массиву и т.д.
const companies = CEOs.reduce((acc, cur) => {
  return acc.concat(cur.companies);
}, []);

console.log(companies);
