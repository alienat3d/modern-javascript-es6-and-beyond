// * 9.0 JavaScript - синхронный однопоточный и блокирующий язык. Это значит, что только 1 процесс может выполняться. На данном примере у нас берётся функция "sayHi", попадает в "call stack", в очередь выполнения, пока не завершится и не вернёт результат, далее в "call stack" попадает функция "askAboutDay" и так далее. Но представим, что у нас также есть функция, которая посылает запрос и принимает данные с какого-то API и мы очевидно не хотим, чтобы всё время ожидания ответа от сервера у нас блокировался сайт и для этого у нас есть асинхронные функции, которые выполняются на заднем плане и не блокируют выполнение остального кода (мы уже встречали подобное поведение, например у метода setTimeout).
// 9.1 Например, если мы добавим к функции "setTimeout" даже с задержкой в 0 мс, то эта функция попадёт в "call stack" только, когда будут выполнены все остальные, т.е. "call stack" освободится.
const sayHi = () => console.log('Hello there!');
const askAboutDay = () => setTimeout(() => console.log('How was your day?'), 0);
const sayBye = () => console.log('See you later!');

sayHi();
askAboutDay();
sayBye();

// ? 9.2 Чтобы упростить асинхронное программирование в ES6 были введены промисы. Промисы (обещания) функционирует вполне себе, как в реальной жизни, мы обещаем что-то совершить в будущем, однако обещание не гарантирует, что это обязательно будет исполнено. Это больше выглядит как намерение сделать что-то в будущем.
// 9.3.0 Рассмотрим на примере из реальной жизни как бы мы могли описать промисом обещание выгулять собаку. Мы используем конструктор промисов, который принимает коллбэк-функцию, которая принимает два аргумента "resolve" & "reject". "resolve" функция может быть вызвана в момент, когда совершается то, что было "обещано" к выполнению в промисе, а "reject" соответственно, если то, что было "обещано" не выполняется. Создадим также переменную, которая будет содержать в себе булево значение, показывающее погуляли ли мы с собакой (хотя в реальной практике на этом месте будет асинхронная функция, которая возвращает какое-то значение после выполнения).
// 9.3.1 Итак, когда наша асинхронная функция выполнится, то вернётся сообщение методом "resolve", а если промис провалится, то методом "reject".
const promiseToWalkDog = new Promise((resolve, reject) => {
  let hasWalkedDog = false;

  if (hasWalkedDog) {
    resolve('I walked the dog.');
  } else {
    reject('I didn’t walk the dog.');
  }
});

// 9.3.2 Далее мы можем что-то сделать с данными, которые возвращает этот промис через метод "then". Этот метод также принимает два аргумента, первый, если промис успешно выполнен, а второй, если на каком-то этапе провалился. Ну, а содержание этих аргументов соответствует тому, что мы поместили ранее в промисе в "resolve" & "reject" методы.
/* promiseToWalkDog.then(
  (fromResolve) => {
    console.log(`Did you walk the dog? ${fromResolve}`);
  },
  (fromReject) => {
    console.log(`Did you walk the dog? ${fromReject}`);
  }
); */
// ? 9.3.3 Однако, вместо второго аргумента в методе "then" (что чаще и используется на практике), можно использовать метод "catch", это "синтаксический сахар" и делает тоже самое, но может улучшить читаемость кода. "catch" метод потому так и называется, что это место, где мы ловим и обрабатываем возможные ошибки при попытке выполнения промиса.
promiseToWalkDog
  .then((fromResolve) => {
    console.log(`Did you walk the dog? ${fromResolve}`);
  })
  .catch((fromReject) => {
    console.log(`Did you walk the dog? ${fromReject}`);
  });

/* ? 9.4 Промис может быть в 3-ёх состояниях: 
	1-ое "pending" — изначальное состояние, в котором находится промис и это состояние "режим ожидания", когда в промисе пока нет ни значения resolve, ни rejected;
	2-ое "fulfilled" - означает, что условия промиса были успешно выполнены;
	3-ее "rejected" - означает, что условия промиса не были выполнены и он провалился;
*/

// 9.5.0 Часто встречаемый пример, на котором объясняются промисы это использование XMLHttpRequest-метод для опроса данных с API.
// 9.5.1 В этом примере мы хотим загрузить случайную картинку собаки при помощи "Dog API" и асинхронной функции "loadImage". Т.к. мы не знаем сколько может достигать время отклика сервера и будет ли он вообще, то логично возвращать результат через промис.
// 9.5.3 Внутри промиса мы создадим запрос на сервер методом "XMLHttpRequest". (более подробно про использование метода "XMLHttpRequest" в ссылке к уроку)
// 9.5.4 Итак, здесь мы получаем данны с помещённого в функцию URL и если полученный от сервера статус 200 (что означает успешно пройденный запрос), то мы поместим этот ответ в "resolve" (сокр. "res") и это будут данные с картинкой.
// ? 9.5.5 Всё это может быть похожим на метод "fetch" и это потому, что он базируется на промисе, а значит мы можем использовать "then" & "catch" методы с ним.
function loadImage(url) {
  return new Promise((res, rej) => {
    const request = new XMLHttpRequest();

    request.open('GET', url);

    request.onload = function () {
      if (request.status === 200) {
        res(request.response);
      } else {
        rej(`Error: ${request.statusText}`);
      }
    };

    request.send();
  });
}

// 9.5.2 Т.к. мы использовали промис, то получить доступ к данным этого промиса мы можем через метод "then".
loadImage('https://dog.ceo/api/breeds/image/random').then((res) =>
  console.log(res)
);

// 9.6.0 Теперь представим, что мы пообещали несколько вещей. Сперва убраться в комнате, после чего погулять с собакой и потом приготовить еду. После того, как были выполнены все промисы один за другим и ни один не провалился мы напишем в консоль сообщение.
let cookFood = () => {
  return new Promise((res) => res('I cooked food.'));
};

let walkDog = () => {
  return new Promise((res) => res('I walked dog.'));
};

let cleanRoom = () => {
  return new Promise((res, rej) => rej('I didn’t clean room.'));
};

/* cleanRoom()
  .then(() => walkDog())
  .then(() => cookFood())
  .then(() => console.log('All done!')); */

// 9.6.1 Но, вместо того, чтобы прописывать цепочкой все промисы друг за другом мы можем написать более лаконично при помощи метода промисов "all", который примет массив с промисами и вернёт массив с возвращёнными из них значениями.
// 9.6.2 Если же хоть один из промисов провалится, то "Promise.all" также синхронно провалится вместе со значением, описанным в методе "rejected" этого провалившегося промиса. И оно будет поймано методом "catch".
// ? 9.6.7 Однако стоит помнить, что метод промиса "all" может запустить их параллельно и они выполнятся не в том порядке, в каком мы их в нём прописали, т.ч. он подходит только, если порядок выполнения нам не важен.
Promise.all([cleanRoom(), walkDog(), cookFood()])
  .then((res) => console.log(res))
  .catch((err) => console.log(err));

// ? 9.7.0 Пока что здесь мы писали промисы самостоятельно, но в случае с работой со сторонними библиотеками мы можем не знать с каким значением мы работаем. Значение может быть, а может и не быть промисом. Т.ч. если мы получаем аргумент, который может оказаться промисом, то можно использовать на нём метод промиса "resolve". Он может принимать аргументом либо промис, либо обычное значение.
// 9.7.1 Создадим простой промис, который возвращает строковое значение, а также переменную со строкой внутри.
// 9.7.2 Как мы видим с методом промиса "resolve" работает и то и другое, в то время как к переменной "myName" мы не можем применять "then", это вызовет ошибку, т.к. это не промис. Это отличный способ предохраниться от возможных ошибок, когда мы точно не знаем будут ли данные промисом или обычными данными, что частый случай, когда мы работаем со сторонними кусочками кода или библиотеками.
const myPromise = new Promise((res) => res('I am a promise.'));
const myName = 'Al';

Promise.resolve(myPromise).then((res) => console.log(res));
Promise.resolve(myName).then((res) => console.log(res));

myPromise.then((res) => console.log(res));
// myName.then((res) => console.log(res)); <-- Throws an error!

// ? 9.8 Промисы позволяют асинхронным функция возвращать данные как синхронные. Вместо того, чтобы выдавать данные сразу же, асинхронная функция выдаст объект промиса, готовый для доступа к данным в будущем.
