// * 22.0 Тип данных Symbol.
// 22.1.0 Рассмотрим какую проблему можно решить с помощью Символов. У нас есть объект "shape" и мы создали две библиотеки. Обе библиотеки изменят объект, который в них попадёт, добавляя в него новое свойство "specialBehavior". В первой библиотеке значение "specialBehavior" это строка. А во второй библиотеке значение "specialBehavior" — функция, которая вернут строку.
// 22.1.2
const randomString = Math.random().toString(36).substring(7);
const randomString2 = Math.random().toString(36).substring(7);

const shape = {
  radius: 10,
};

function libraryOne(obj) {
  // obj.specialBehavior = 'Library one!';
  obj[randomString] = 'Library one!';
}

function libraryTwo(obj) {
  /* obj.specialBehavior = function () {
    return 'Library two!';
  }; */
  obj[randomString2] = function () {
    return 'Library two!';
  };
}

libraryOne(shape);
libraryTwo(shape);

// ? 22.1.1 И вот мы видим, что вторая библиотека перезаписала значение, которое было записано первой библиотекой, т.е. строку на функцию. Функционал первой библиотеки просто пропал. Но ладно, это простой смешной пример и мы знаем точно где ошибка, но представим, что мы в реальном проекте и эти библиотеки были написаны двумя разными, никак не связанными друг с другом разработчиками. Тогда существует высокий риск, что будет иметь место проблема перезаписывания из-за одинакового нейминга. Чтобы этого избежать нужно как-то удостовериться, что у нас действительно уникальные имена у свойств. И один из способов это сгенерировать уникальные имена для свойств объекта, например, используя библиотеки-генераторы случайных чисел или метод "Math.random". ↑
console.log(shape);

// ? 21.1.3 Ок, при помощи генератора случайных строк мы справились с задачей, но всё же решение выглядит не оптимальным, т.к. стало сложно понять, что именно находится в этих свойствах. А может быть нам нужно даже где-то выводить название этих свойств в какую-то кнопку для пользователя. Чтобы это исправить лучше использовать тип данных Символ. Они как раз и работают как идентификатор для свойств объекта.
// ? 21.2 Создают Символ с помощью функции Symbol() и каждый раз, когда эта функция вызывается - она возвращает уникальное значение (но на самом деле мы это значение не увидим, а что она в действительности возвращает тип данных "symbol"). Но т.к. каждый Symbol абсолютно уникален, то мы можем быть уверены, что избежим перезаписывания свойств объекта.
console.log(typeof Symbol());

// ? 21.3 Мы также можем добавить описание Символу, что может быть полезно при дебаггинге или тестах. Это описание никак не влияет на значение под этим Символом, это всего лишь информация для отладки.
const mySymbol = Symbol('This is the description');

console.log(mySymbol);

// 21.4 Итак, теперь перепишем код сверху под Символы. И как мы видим в консоли, всё отлично сработало и функционал из обеих библиотек внутри объекта "anotherShape"!
const anotherShape = {
  radius: 10,
};

function libOne(obj) {
  obj[Symbol('specialBehavior')] = 'Functionality that libOne added';
}

function libTwo(obj) {
  obj[Symbol('specialBehavior')] = function () {
    return 'Functionality that libTwo added';
  };
}

libOne(anotherShape);
libTwo(anotherShape);

console.log(anotherShape);

// ? 21.5 Что стоит ещё знать про Символы, что они не перечисляемые, а значит мы можем создавать с помощью них своего рода приватные свойства объектов. "Своего рода", т.к. они в действительности не приватные. Мы всё ещё можем получить к ним доступ при помощи метода "Object.getOwnPropertySymbols"
for (let item in anotherShape) console.log(item);

console.log(Object.getOwnPropertySymbols(anotherShape));

// ? 21.6 Также возможно получить доступ к значению Символа через метод "find", применяемый к массиву, полученному при помощи метода "Object.getOwnPropertySymbols".
const symbolValue = Object.getOwnPropertySymbols(anotherShape).find(
  (s) => String(s) === 'Symbol(specialBehavior)'
);

console.log(anotherShape[symbolValue]);
